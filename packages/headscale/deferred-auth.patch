Commit ID: 9803b8ce2460772ba0eaae7b245d10009ba6a00b
Change ID: rmzrrlvnpvlukyuotstptzuvnkvkssps
Bookmarks: private/minion/push-rmzrrlvnpvlu private/minion/push-rmzrrlvnpvlu@git private/minion/push-rmzrrlvnpvlu@origin
Author   : Skyler Grey <minion@freshlybakedca.ke> (2025-09-13 14:04:34)
Committer: Skyler Grey <minion@freshlybakedca.ke> (2025-09-13 14:41:03)
Signature: good signature by sky@a.starrysky.fyi

    oidc: allow deferring auth provider setup

    Currently, if Headscale fails to set up OIDC when it is starting up
    there are two cases. Either:
    - only_start_if_oidc_is_available is true and Headscale fails to start
    - only_start_if_oidc_is_available is false and Headscale disables OIDC
      until it is restarted

    In our setup, we rely on Headscale for any remote SSH access. As most
    users don't have any physical access we can't afford to have Headscale
    fail to start. This, however, means that if Headscale starts without our
    auth provider having yet started (as frequently happens) we will not be
    able to authenticate via OIDC until we restart headscale.

    This patch adds a new config option ('auth_setup_allow_defer') to soft
    fail on setting up OIDC until we attempt registration. At that point if
    OIDC still doesn't work authentication will fail (i.e. there will not be
    the option to login via the command line)

    fixes: juanfont/headscale#1873

diff --git a/hscontrol/app.go b/hscontrol/app.go
index 6880c6bed8..152d014a69 100644
--- a/hscontrol/app.go
+++ b/hscontrol/app.go
@@ -112,6 +112,40 @@
 	dumpConfig       = envknob.Bool("HEADSCALE_DEBUG_DUMP_CONFIG")
 )
 
+func (h *Headscale) InitOrGetAuthProvider(ctx context.Context) (*AuthProvider, error) {
+	if h.authProvider != nil {
+		return &h.authProvider, nil
+	}
+
+	var authProvider AuthProvider
+	authProvider = NewAuthProviderWeb(h.cfg.ServerURL)
+	if h.cfg.OIDC.Issuer != "" {
+		ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
+		defer cancel()
+		oidcProvider, err := NewAuthProviderOIDC(
+			ctx,
+			h,
+			h.cfg.ServerURL,
+			&h.cfg.OIDC,
+		)
+		if err != nil {
+			if h.cfg.OIDC.OnlyStartIfOIDCIsAvailable {
+				return nil, err
+			} else if h.cfg.AuthSetupAllowDefer {
+				log.Warn().Err(err).Msg("failed to set up OIDC provider, deferring until I get an auth request")
+				authProvider = nil
+			} else {
+				log.Warn().Err(err).Msg("failed to set up OIDC provider, falling back to CLI based authentication")
+			}
+		} else {
+			authProvider = oidcProvider
+		}
+	}
+	h.authProvider = authProvider
+
+	return &h.authProvider, nil
+}
+
 func NewHeadscale(cfg *types.Config) (*Headscale, error) {
 	var err error
 	if profilingEnabled {
@@ -155,28 +189,10 @@
 	})
 	app.ephemeralGC = ephemeralGC
 
-	var authProvider AuthProvider
-	authProvider = NewAuthProviderWeb(cfg.ServerURL)
-	if cfg.OIDC.Issuer != "" {
-		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
-		defer cancel()
-		oidcProvider, err := NewAuthProviderOIDC(
-			ctx,
-			&app,
-			cfg.ServerURL,
-			&cfg.OIDC,
-		)
-		if err != nil {
-			if cfg.OIDC.OnlyStartIfOIDCIsAvailable {
-				return nil, err
-			} else {
-				log.Warn().Err(err).Msg("failed to set up OIDC provider, falling back to CLI based authentication")
-			}
-		} else {
-			authProvider = oidcProvider
-		}
+	_, err = app.InitOrGetAuthProvider(context.Background())
+	if err != nil {
+		return nil, err
 	}
-	app.authProvider = authProvider
 
 	if app.cfg.TailcfgDNSConfig != nil && app.cfg.TailcfgDNSConfig.Proxied { // if MagicDNS
 		// TODO(kradalby): revisit why this takes a list.
@@ -455,12 +471,37 @@
 	router.HandleFunc("/robots.txt", h.RobotsHandler).Methods(http.MethodGet)
 	router.HandleFunc("/health", h.HealthHandler).Methods(http.MethodGet)
 	router.HandleFunc("/key", h.KeyHandler).Methods(http.MethodGet)
-	router.HandleFunc("/register/{registration_id}", h.authProvider.RegisterHandler).
+	router.HandleFunc("/register/{registration_id}", func(writer http.ResponseWriter, req *http.Request) {
+		authProvider, err := h.InitOrGetAuthProvider(req.Context())
+		if authProvider == nil {
+			log.Warn().Err(err).Msg("failed to setup auth on registration request")
+			writer.WriteHeader(http.StatusInternalServerError)
+			return
+		}
+
+		h.authProvider.RegisterHandler(writer, req)
+	}).
 		Methods(http.MethodGet)
 
-	if provider, ok := h.authProvider.(*AuthProviderOIDC); ok {
-		router.HandleFunc("/oidc/callback", provider.OIDCCallbackHandler).Methods(http.MethodGet)
-	}
+	router.HandleFunc("/oidc/callback", func(writer http.ResponseWriter, req *http.Request) {
+		if h.cfg.OIDC.Issuer == "" {
+			writer.WriteHeader(http.StatusNotFound)
+			return
+		}
+
+		authProvider, err := h.InitOrGetAuthProvider(req.Context())
+		if authProvider == nil {
+			log.Warn().Err(err).Msg("failed to setup auth on registration request")
+			return
+		}
+
+		if provider, ok := (*authProvider).(*AuthProviderOIDC); ok {
+			provider.OIDCCallbackHandler(writer, req)
+			return
+		}
+
+		writer.WriteHeader(http.StatusInternalServerError)
+	}).Methods(http.MethodGet)
 	router.HandleFunc("/apple", h.AppleConfigMessage).Methods(http.MethodGet)
 	router.HandleFunc("/apple/{platform}", h.ApplePlatformConfig).
 		Methods(http.MethodGet)
diff --git a/hscontrol/auth.go b/hscontrol/auth.go
index 81032640ce..9c018da908 100644
--- a/hscontrol/auth.go
+++ b/hscontrol/auth.go
@@ -266,7 +266,13 @@
 
 	log.Info().Msgf("Starting node registration using key: %s", registrationId)
 
+	authProvider, err := h.InitOrGetAuthProvider(context.Background())
+	if authProvider == nil {
+		log.Error().Err(err).Msg("Failed to get auth provider when registering node")
+		return nil, fmt.Errorf("getting auth provider when registering node: %w", err)
+	}
+
 	return &tailcfg.RegisterResponse{
-		AuthURL: h.authProvider.AuthURL(registrationId),
+		AuthURL: (*authProvider).AuthURL(registrationId),
 	}, nil
 }
diff --git a/hscontrol/types/config.go b/hscontrol/types/config.go
index 4a0a366eb2..18227d391f 100644
--- a/hscontrol/types/config.go
+++ b/hscontrol/types/config.go
@@ -88,7 +88,8 @@
 	UnixSocket           string
 	UnixSocketPermission fs.FileMode
 
-	OIDC OIDCConfig
+	AuthSetupAllowDefer bool
+	OIDC                OIDCConfig
 
 	LogTail             LogTailConfig
 	RandomizeClientPort bool
@@ -941,6 +942,7 @@
 		UnixSocket:           viper.GetString("unix_socket"),
 		UnixSocketPermission: util.GetFileMode("unix_socket_permission"),
 
+		AuthSetupAllowDefer: viper.GetBool("auth_setup_allow_defer"),
 		OIDC: OIDCConfig{
 			OnlyStartIfOIDCIsAvailable: viper.GetBool(
 				"oidc.only_start_if_oidc_is_available",
